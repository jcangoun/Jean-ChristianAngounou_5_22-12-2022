"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  utils: () => utils
});
module.exports = __toCommonJS(src_exports);
var import_node_fs = require("fs");
var import_gzip_size = __toESM(require("gzip-size"));
var utils = {};
utils.readFile = (file) => (0, import_node_fs.readFileSync)(file, "utf8");
utils.writeFile = ({ file, content, index }) => {
  const _file = index !== void 0 ? file[index] : file;
  if (!(0, import_node_fs.existsSync)(_file) || (0, import_node_fs.existsSync)(_file) && !(0, import_node_fs.lstatSync)(_file).isDirectory()) {
    (0, import_node_fs.writeFileSync)(_file, content, "utf8");
  }
  return content;
};
utils.deleteFile = (file) => (0, import_node_fs.unlinkSync)(file);
utils.buildArgs = (options) => {
  const args = [];
  Object.keys(options).forEach((key) => {
    if (options[key] && options[key] !== false) {
      args.push("--" + key);
    }
    if (options[key] && options[key] !== true) {
      args.push(options[key]);
    }
  });
  return args;
};
utils.clone = (obj) => JSON.parse(JSON.stringify(obj));
utils.getFilesizeInBytes = (file) => {
  const stats = (0, import_node_fs.statSync)(file);
  const fileSizeInBytes = stats.size;
  return utils.prettyBytes(fileSizeInBytes);
};
utils.getFilesizeGzippedInBytes = (file) => {
  return new Promise((resolve) => {
    const source = (0, import_node_fs.createReadStream)(file);
    source.pipe(import_gzip_size.default.stream()).on("gzip-size", (size) => {
      resolve(utils.prettyBytes(size));
    });
  });
};
utils.prettyBytes = (num) => {
  const UNITS = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  if (!Number.isFinite(num)) {
    throw new TypeError(`Expected a finite number, got ${typeof num}: ${num}`);
  }
  const neg = num < 0;
  if (neg) {
    num = -num;
  }
  if (num < 1) {
    return (neg ? "-" : "") + num + " B";
  }
  const exponent = Math.min(Math.floor(Math.log(num) / Math.log(1e3)), UNITS.length - 1);
  const numStr = Number((num / Math.pow(1e3, exponent)).toPrecision(3));
  const unit = UNITS[exponent];
  return (neg ? "-" : "") + numStr + " " + unit;
};
utils.setFileNameMin = (file, output, publicFolder, replaceInPlace) => {
  const filePath = file.substr(0, file.lastIndexOf("/") + 1);
  const fileWithoutPath = file.substr(file.lastIndexOf("/") + 1);
  let fileWithoutExtension = fileWithoutPath.substr(0, fileWithoutPath.lastIndexOf("."));
  if (publicFolder) {
    fileWithoutExtension = publicFolder + fileWithoutExtension;
  }
  if (replaceInPlace) {
    fileWithoutExtension = filePath + fileWithoutExtension;
  }
  return output.replace("$1", fileWithoutExtension);
};
utils.compressSingleFile = (settings) => {
  const content = settings.content ? settings.content : settings.input ? utils.getContentFromFiles(settings.input) : "";
  return settings.sync ? utils.runSync({ settings, content }) : utils.runAsync({ settings, content });
};
utils.getContentFromFiles = (input) => {
  if (!Array.isArray(input)) {
    return (0, import_node_fs.readFileSync)(input, "utf8");
  }
  return input.map(
    (path) => !(0, import_node_fs.existsSync)(path) || (0, import_node_fs.existsSync)(path) && !(0, import_node_fs.lstatSync)(path).isDirectory() ? (0, import_node_fs.readFileSync)(path, "utf8") : ""
  ).join("\n");
};
utils.runSync = ({ settings, content, index }) => settings && typeof settings.compressor !== "string" ? typeof settings.compressor === "function" ? settings.compressor({ settings, content, callback: null, index }) : "" : "";
utils.runAsync = ({ settings, content, index }) => {
  return new Promise((resolve, reject) => {
    settings && settings.compressor && typeof settings.compressor !== "string" ? settings.compressor({
      settings,
      content,
      callback: (err, result) => {
        if (err) {
          return reject(err);
        }
        resolve(result || "");
      },
      index
    }) : null;
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  utils
});
/*!
 * node-minify
 * Copyright(c) 2011-2023 Rodolphe Stoclin
 * MIT Licensed
 */
//# sourceMappingURL=index.js.map