{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/*!\n * node-minify\n * Copyright(c) 2011-2023 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport { readFileSync, lstatSync, statSync, existsSync, writeFileSync, unlinkSync, createReadStream } from 'node:fs';\nimport gzipSize from 'gzip-size';\nimport { MinifierOptions, Settings, OptionsPossible } from '@node-minify/types';\n\ntype Utils = {\n  readFile: (file: string) => string;\n  writeFile: ({ file, content, index }: WriteFile) => string;\n  deleteFile: (file: string) => void;\n  buildArgs: (options: Record<string, OptionsPossible>) => any;\n  clone: (obj: object) => object;\n  getFilesizeInBytes: (file: string) => string;\n  getFilesizeGzippedInBytes: (file: string) => Promise<string>;\n  prettyBytes: (num: number) => string;\n  setFileNameMin: (file: string, output: string, publicFolder?: string, replaceInPlace?: boolean) => string;\n  compressSingleFile: (settings: Settings) => string | Promise<string>;\n  getContentFromFiles: (input: string | string[]) => string;\n  runSync: ({ settings, content, index }: MinifierOptions) => string;\n  runAsync: ({ settings, content, index }: MinifierOptions) => Promise<string>;\n};\n\ntype WriteFile = {\n  file: string;\n  content: any;\n  index?: number;\n};\n\nconst utils = {} as Utils;\n\n/**\n * Read content from file.\n *\n * @param {String} file\n * @returns {String}\n */\nutils.readFile = (file: string): string => readFileSync(file, 'utf8');\n\n/**\n * Write content into file.\n *\n * @param {String} file\n * @param {String} content\n * @param {Number} index - index of the file being processed\n * @returns {String}\n */\nutils.writeFile = ({ file, content, index }: WriteFile): string => {\n  const _file = index !== undefined ? file[index] : file;\n  if (!existsSync(_file) || (existsSync(_file) && !lstatSync(_file).isDirectory())) {\n    writeFileSync(_file, content, 'utf8');\n  }\n\n  return content;\n};\n\n/**\n * Delete file.\n *\n * @param {String} file\n */\nutils.deleteFile = (file: string) => unlinkSync(file);\n\n/**\n * Builds arguments array based on an object.\n *\n * @param {Object} options\n * @returns {Array}\n */\nutils.buildArgs = (options: Record<string, OptionsPossible>): OptionsPossible[] => {\n  const args: OptionsPossible[] = [];\n  Object.keys(options).forEach((key: string) => {\n    if (options[key] && options[key] !== false) {\n      args.push('--' + key);\n    }\n\n    if (options[key] && options[key] !== true) {\n      args.push(options[key]);\n    }\n  });\n\n  return args;\n};\n\n/**\n * Clone an object.\n *\n * @param {Object} obj\n * @returns {Object}\n */\nutils.clone = (obj: object): object => JSON.parse(JSON.stringify(obj));\n\n/**\n * Get the file size in bytes.\n *\n * @returns {String}\n */\nutils.getFilesizeInBytes = (file: string): string => {\n  const stats = statSync(file);\n  const fileSizeInBytes = stats.size;\n  return utils.prettyBytes(fileSizeInBytes);\n};\n\n/**\n * Get the gzipped file size in bytes.\n *\n * @returns {Promise.<String>}\n */\nutils.getFilesizeGzippedInBytes = (file: string): Promise<string> => {\n  return new Promise(resolve => {\n    const source = createReadStream(file);\n    source.pipe(gzipSize.stream()).on('gzip-size', size => {\n      resolve(utils.prettyBytes(size));\n    });\n  });\n};\n\n/**\n * Get the size in human readable.\n * From https://github.com/sindresorhus/pretty-bytes\n *\n * @returns {String}\n */\nutils.prettyBytes = (num: number): string => {\n  const UNITS = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n  if (!Number.isFinite(num)) {\n    throw new TypeError(`Expected a finite number, got ${typeof num}: ${num}`);\n  }\n\n  const neg = num < 0;\n\n  if (neg) {\n    num = -num;\n  }\n\n  if (num < 1) {\n    return (neg ? '-' : '') + num + ' B';\n  }\n\n  const exponent = Math.min(Math.floor(Math.log(num) / Math.log(1000)), UNITS.length - 1);\n  const numStr = Number((num / Math.pow(1000, exponent)).toPrecision(3));\n  const unit = UNITS[exponent];\n\n  return (neg ? '-' : '') + numStr + ' ' + unit;\n};\n\n/**\n * Set the file name as minified.\n * eg. file.js returns file.min.js\n *\n * @param {String} file\n * @param {String} output\n * @param {String} publicFolder\n * @param {Boolean} replaceInPlace\n * @returns {String}\n */\nutils.setFileNameMin = (file: string, output: string, publicFolder?: string, replaceInPlace?: boolean): string => {\n  const filePath = file.substr(0, file.lastIndexOf('/') + 1);\n  const fileWithoutPath = file.substr(file.lastIndexOf('/') + 1);\n  let fileWithoutExtension = fileWithoutPath.substr(0, fileWithoutPath.lastIndexOf('.'));\n  if (publicFolder) {\n    fileWithoutExtension = publicFolder + fileWithoutExtension;\n  }\n  if (replaceInPlace) {\n    fileWithoutExtension = filePath + fileWithoutExtension;\n  }\n  return output.replace('$1', fileWithoutExtension);\n};\n\n/**\n * Compress a single file.\n *\n * @param {Object} settings\n */\nutils.compressSingleFile = (settings: Settings): Promise<string> | string => {\n  const content = settings.content ? settings.content : settings.input ? utils.getContentFromFiles(settings.input) : '';\n  return settings.sync ? utils.runSync({ settings, content }) : utils.runAsync({ settings, content });\n};\n\n/**\n * Concatenate all input files and get the data.\n *\n * @param {String|Array} input\n * @return {String}\n */\nutils.getContentFromFiles = (input: string | string[]): string => {\n  if (!Array.isArray(input)) {\n    return readFileSync(input, 'utf8');\n  }\n\n  return input\n    .map(path =>\n      !existsSync(path) || (existsSync(path) && !lstatSync(path).isDirectory()) ? readFileSync(path, 'utf8') : ''\n    )\n    .join('\\n');\n};\n\n/**\n * Run compressor in sync.\n *\n * @param {Object} settings\n * @param {String} content\n * @param {Number} index - index of the file being processed\n * @return {String}\n */\nutils.runSync = ({ settings, content, index }: MinifierOptions): string =>\n  settings && typeof settings.compressor !== 'string'\n    ? typeof settings.compressor === 'function'\n      ? settings.compressor({ settings, content, callback: null, index })\n      : ''\n    : '';\n\n/**\n * Run compressor in async.\n *\n * @param {Object} settings\n * @param {String} content\n * @param {Number} index - index of the file being processed\n * @return {Promise}\n */\nutils.runAsync = ({ settings, content, index }: MinifierOptions): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    settings && settings.compressor && typeof settings.compressor !== 'string'\n      ? settings.compressor({\n          settings,\n          content,\n          callback: (err: unknown, result?: string) => {\n            if (err) {\n              return reject(err);\n            }\n            resolve(result || '');\n          },\n          index\n        })\n      : null;\n  });\n};\n\n/**\n * Expose `utils`.\n */\nexport { utils };\n"],"mappings":"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","names":[]}