var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/setup.ts
import path from "path";
import { globSync } from "glob";
import { utils } from "@node-minify/utils";
var defaultSettings, setup, checkOutput, wildcards, wildcardsString, wildcardsArray, getFilesFromWildcards, setPublicFolder, checkMandatories, checkMandatoriesMemoryContent, mandatory;
var init_setup = __esm({
  "src/setup.ts"() {
    "use strict";
    defaultSettings = {
      sync: false,
      options: {},
      buffer: 1e3 * 1024,
      callback: false
    };
    setup = (inputSettings) => {
      let settings = Object.assign(utils.clone(defaultSettings), inputSettings);
      if (settings.content) {
        checkMandatoriesMemoryContent(inputSettings);
        return settings;
      }
      checkMandatories(inputSettings);
      if (settings.input) {
        settings = Object.assign(settings, wildcards(settings.input, settings.publicFolder));
      }
      if (settings.input && settings.output) {
        settings = Object.assign(
          settings,
          checkOutput(settings.input, settings.output, settings.publicFolder, settings.replaceInPlace)
        );
      }
      if (settings.input && settings.publicFolder) {
        settings = Object.assign(settings, setPublicFolder(settings.input, settings.publicFolder));
      }
      return settings;
    };
    checkOutput = (input, output, publicFolder, replaceInPlace) => {
      const reg = new RegExp("\\$1");
      if (reg.test(output)) {
        if (Array.isArray(input)) {
          const outputMin = input.map(
            (file) => utils.setFileNameMin(file, output, replaceInPlace ? void 0 : publicFolder, replaceInPlace)
          );
          return { output: outputMin };
        } else {
          return { output: utils.setFileNameMin(input, output, replaceInPlace ? void 0 : publicFolder, replaceInPlace) };
        }
      }
    };
    wildcards = (input, publicFolder) => {
      if (!Array.isArray(input)) {
        return wildcardsString(input, publicFolder);
      }
      return wildcardsArray(input, publicFolder);
    };
    wildcardsString = (input, publicFolder) => {
      const output = {};
      if (input.indexOf("*") > -1) {
        output.input = getFilesFromWildcards(input, publicFolder);
      }
      return output;
    };
    wildcardsArray = (input, publicFolder) => {
      const output = {};
      let isWildcardsPresent = false;
      output.input = input;
      const inputWithPublicFolder = input.map((item) => {
        if (item.indexOf("*") > -1) {
          isWildcardsPresent = true;
        }
        return (publicFolder || "") + item;
      });
      if (isWildcardsPresent) {
        output.input = globSync(inputWithPublicFolder);
      }
      for (let i = 0; i < output.input.length; i++) {
        if (output.input[i].indexOf("*") > -1) {
          output.input.splice(i, 1);
          i--;
        }
      }
      return output;
    };
    getFilesFromWildcards = (input, publicFolder) => {
      let output = [];
      if (input.indexOf("*") > -1) {
        output = globSync((publicFolder || "") + input);
      }
      return output;
    };
    setPublicFolder = (input, publicFolder) => {
      const output = {};
      if (typeof publicFolder !== "string") {
        return output;
      }
      publicFolder = path.normalize(publicFolder);
      if (Array.isArray(input)) {
        output.input = input.map((item) => {
          if (path.normalize(item).indexOf(publicFolder) > -1) {
            return item;
          }
          return path.normalize(publicFolder + item);
        });
        return output;
      }
      input = path.normalize(input);
      if (input.indexOf(publicFolder) > -1) {
        output.input = input;
        return output;
      }
      output.input = path.normalize(publicFolder + input);
      return output;
    };
    checkMandatories = (settings) => {
      ["compressor", "input", "output"].forEach((item) => mandatory(item, settings));
    };
    checkMandatoriesMemoryContent = (settings) => {
      ["compressor", "content"].forEach((item) => mandatory(item, settings));
    };
    mandatory = (setting, settings) => {
      if (!settings[setting]) {
        throw new Error(setting + " is mandatory.");
      }
    };
  }
});

// src/compress.ts
import fs from "fs";
import mkdirp from "mkdirp";
import { utils as utils2 } from "@node-minify/utils";
var compress, compressArrayOfFilesSync, compressArrayOfFilesAsync, createDirectory;
var init_compress = __esm({
  "src/compress.ts"() {
    "use strict";
    compress = (settings) => {
      if (typeof settings.compressor !== "function") {
        throw new Error(`compressor should be a function, maybe you forgot to install the compressor`);
      }
      if (settings.output) {
        createDirectory(settings.output);
      }
      if (Array.isArray(settings.output)) {
        return settings.sync ? compressArrayOfFilesSync(settings) : compressArrayOfFilesAsync(settings);
      } else {
        return utils2.compressSingleFile(settings);
      }
    };
    compressArrayOfFilesSync = (settings) => {
      return Array.isArray(settings.input) && settings.input.forEach((input, index) => {
        const content = utils2.getContentFromFiles(input);
        return utils2.runSync({ settings, content, index });
      });
    };
    compressArrayOfFilesAsync = (settings) => {
      let sequence = Promise.resolve();
      Array.isArray(settings.input) && settings.input.forEach((input, index) => {
        const content = utils2.getContentFromFiles(input);
        sequence = sequence.then(() => utils2.runAsync({ settings, content, index }));
      });
      return sequence;
    };
    createDirectory = (file) => {
      if (Array.isArray(file)) {
        file = file[0];
      }
      const dir = file && file.substr(0, file.lastIndexOf("/"));
      if (!dir) {
        return;
      }
      if (!fs.statSync(dir).isDirectory()) {
        mkdirp.sync(dir);
      }
    };
  }
});

// src/compressInMemory.ts
import { utils as utils3 } from "@node-minify/utils";
var compressInMemory;
var init_compressInMemory = __esm({
  "src/compressInMemory.ts"() {
    "use strict";
    compressInMemory = (settings) => {
      if (typeof settings.compressor !== "function") {
        throw new Error(`compressor should be a function, maybe you forgot to install the compressor`);
      }
      return utils3.compressSingleFile(settings);
    };
  }
});

// src/index.ts
var require_src = __commonJS({
  "src/index.ts"(exports, module) {
    init_setup();
    init_compress();
    init_compressInMemory();
    var minify = (settings) => {
      return new Promise((resolve, reject) => {
        const method = settings.content ? compressInMemory : compress;
        settings = setup(settings);
        if (!settings.sync) {
          method(settings).then((minified) => {
            if (settings.callback) {
              settings.callback(null, minified);
            }
            resolve(minified);
          }).catch((err) => {
            if (settings.callback) {
              settings.callback(err);
            }
            reject(err);
          });
        } else {
          const minified = method(settings);
          if (settings.callback) {
            settings.callback(null, minified);
          }
          resolve(minified);
        }
      });
    };
    minify.default = minify;
    module.exports = minify;
  }
});
export default require_src();
/*!
 * node-minify
 * Copyright(c) 2011-2023 Rodolphe Stoclin
 * MIT Licensed
 */
//# sourceMappingURL=index.mjs.map