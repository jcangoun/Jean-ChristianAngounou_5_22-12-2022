"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/setup.ts
var import_path = __toESM(require("path"));
var import_glob = require("glob");
var import_utils = require("@node-minify/utils");
var defaultSettings = {
  sync: false,
  options: {},
  buffer: 1e3 * 1024,
  callback: false
};
var setup = (inputSettings) => {
  let settings = Object.assign(import_utils.utils.clone(defaultSettings), inputSettings);
  if (settings.content) {
    checkMandatoriesMemoryContent(inputSettings);
    return settings;
  }
  checkMandatories(inputSettings);
  if (settings.input) {
    settings = Object.assign(settings, wildcards(settings.input, settings.publicFolder));
  }
  if (settings.input && settings.output) {
    settings = Object.assign(
      settings,
      checkOutput(settings.input, settings.output, settings.publicFolder, settings.replaceInPlace)
    );
  }
  if (settings.input && settings.publicFolder) {
    settings = Object.assign(settings, setPublicFolder(settings.input, settings.publicFolder));
  }
  return settings;
};
var checkOutput = (input, output, publicFolder, replaceInPlace) => {
  const reg = new RegExp("\\$1");
  if (reg.test(output)) {
    if (Array.isArray(input)) {
      const outputMin = input.map(
        (file) => import_utils.utils.setFileNameMin(file, output, replaceInPlace ? void 0 : publicFolder, replaceInPlace)
      );
      return { output: outputMin };
    } else {
      return { output: import_utils.utils.setFileNameMin(input, output, replaceInPlace ? void 0 : publicFolder, replaceInPlace) };
    }
  }
};
var wildcards = (input, publicFolder) => {
  if (!Array.isArray(input)) {
    return wildcardsString(input, publicFolder);
  }
  return wildcardsArray(input, publicFolder);
};
var wildcardsString = (input, publicFolder) => {
  const output = {};
  if (input.indexOf("*") > -1) {
    output.input = getFilesFromWildcards(input, publicFolder);
  }
  return output;
};
var wildcardsArray = (input, publicFolder) => {
  const output = {};
  let isWildcardsPresent = false;
  output.input = input;
  const inputWithPublicFolder = input.map((item) => {
    if (item.indexOf("*") > -1) {
      isWildcardsPresent = true;
    }
    return (publicFolder || "") + item;
  });
  if (isWildcardsPresent) {
    output.input = (0, import_glob.globSync)(inputWithPublicFolder);
  }
  for (let i = 0; i < output.input.length; i++) {
    if (output.input[i].indexOf("*") > -1) {
      output.input.splice(i, 1);
      i--;
    }
  }
  return output;
};
var getFilesFromWildcards = (input, publicFolder) => {
  let output = [];
  if (input.indexOf("*") > -1) {
    output = (0, import_glob.globSync)((publicFolder || "") + input);
  }
  return output;
};
var setPublicFolder = (input, publicFolder) => {
  const output = {};
  if (typeof publicFolder !== "string") {
    return output;
  }
  publicFolder = import_path.default.normalize(publicFolder);
  if (Array.isArray(input)) {
    output.input = input.map((item) => {
      if (import_path.default.normalize(item).indexOf(publicFolder) > -1) {
        return item;
      }
      return import_path.default.normalize(publicFolder + item);
    });
    return output;
  }
  input = import_path.default.normalize(input);
  if (input.indexOf(publicFolder) > -1) {
    output.input = input;
    return output;
  }
  output.input = import_path.default.normalize(publicFolder + input);
  return output;
};
var checkMandatories = (settings) => {
  ["compressor", "input", "output"].forEach((item) => mandatory(item, settings));
};
var checkMandatoriesMemoryContent = (settings) => {
  ["compressor", "content"].forEach((item) => mandatory(item, settings));
};
var mandatory = (setting, settings) => {
  if (!settings[setting]) {
    throw new Error(setting + " is mandatory.");
  }
};

// src/compress.ts
var import_fs = __toESM(require("fs"));
var import_mkdirp = __toESM(require("mkdirp"));
var import_utils2 = require("@node-minify/utils");
var compress = (settings) => {
  if (typeof settings.compressor !== "function") {
    throw new Error(`compressor should be a function, maybe you forgot to install the compressor`);
  }
  if (settings.output) {
    createDirectory(settings.output);
  }
  if (Array.isArray(settings.output)) {
    return settings.sync ? compressArrayOfFilesSync(settings) : compressArrayOfFilesAsync(settings);
  } else {
    return import_utils2.utils.compressSingleFile(settings);
  }
};
var compressArrayOfFilesSync = (settings) => {
  return Array.isArray(settings.input) && settings.input.forEach((input, index) => {
    const content = import_utils2.utils.getContentFromFiles(input);
    return import_utils2.utils.runSync({ settings, content, index });
  });
};
var compressArrayOfFilesAsync = (settings) => {
  let sequence = Promise.resolve();
  Array.isArray(settings.input) && settings.input.forEach((input, index) => {
    const content = import_utils2.utils.getContentFromFiles(input);
    sequence = sequence.then(() => import_utils2.utils.runAsync({ settings, content, index }));
  });
  return sequence;
};
var createDirectory = (file) => {
  if (Array.isArray(file)) {
    file = file[0];
  }
  const dir = file && file.substr(0, file.lastIndexOf("/"));
  if (!dir) {
    return;
  }
  if (!import_fs.default.statSync(dir).isDirectory()) {
    import_mkdirp.default.sync(dir);
  }
};

// src/compressInMemory.ts
var import_utils3 = require("@node-minify/utils");
var compressInMemory = (settings) => {
  if (typeof settings.compressor !== "function") {
    throw new Error(`compressor should be a function, maybe you forgot to install the compressor`);
  }
  return import_utils3.utils.compressSingleFile(settings);
};

// src/index.ts
var minify = (settings) => {
  return new Promise((resolve, reject) => {
    const method = settings.content ? compressInMemory : compress;
    settings = setup(settings);
    if (!settings.sync) {
      method(settings).then((minified) => {
        if (settings.callback) {
          settings.callback(null, minified);
        }
        resolve(minified);
      }).catch((err) => {
        if (settings.callback) {
          settings.callback(err);
        }
        reject(err);
      });
    } else {
      const minified = method(settings);
      if (settings.callback) {
        settings.callback(null, minified);
      }
      resolve(minified);
    }
  });
};
minify.default = minify;
module.exports = minify;
/*!
 * node-minify
 * Copyright(c) 2011-2023 Rodolphe Stoclin
 * MIT Licensed
 */
//# sourceMappingURL=index.js.map