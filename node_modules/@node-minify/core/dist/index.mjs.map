{"version":3,"sources":["../src/setup.ts","../src/compress.ts","../src/compressInMemory.ts","../src/index.ts"],"sourcesContent":["/*!\n * node-minify\n * Copyright(c) 2011-2023 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport path from 'path';\nimport { globSync } from 'glob';\nimport { utils } from '@node-minify/utils';\nimport { Settings } from '@node-minify/types';\n\n/**\n * Default settings.\n */\nconst defaultSettings = {\n  sync: false,\n  options: {},\n  buffer: 1000 * 1024,\n  callback: false\n};\n\n/**\n * Run setup.\n *\n * @param {Object} inputSettings\n * @return {Object}\n */\nconst setup = (inputSettings: Settings) => {\n  let settings: Settings = Object.assign(utils.clone(defaultSettings), inputSettings);\n\n  // In memory\n  if (settings.content) {\n    checkMandatoriesMemoryContent(inputSettings);\n    return settings;\n  }\n\n  checkMandatories(inputSettings);\n\n  if (settings.input) {\n    settings = Object.assign(settings, wildcards(settings.input, settings.publicFolder));\n  }\n  if (settings.input && settings.output) {\n    settings = Object.assign(\n      settings,\n      checkOutput(settings.input, settings.output, settings.publicFolder, settings.replaceInPlace)\n    );\n  }\n  if (settings.input && settings.publicFolder) {\n    settings = Object.assign(settings, setPublicFolder(settings.input, settings.publicFolder));\n  }\n\n  return settings;\n};\n\n/**\n * Check the output path, searching for $1\n * if exist, returns the path remplacing $1 by file name\n *\n * @param {String|Array} input - Path file\n * @param {String} output - Path to the output file\n * @param {String} publicFolder - Path to the public folder\n * @param {Boolean} replaceInPlace - True to replace file in same folder\n * @return {Object}\n */\nconst checkOutput = (input: string | string[], output: string, publicFolder?: string, replaceInPlace?: boolean) => {\n  const reg = new RegExp('\\\\$1');\n  if (reg.test(output)) {\n    if (Array.isArray(input)) {\n      const outputMin = input.map(file =>\n        utils.setFileNameMin(file, output, replaceInPlace ? undefined : publicFolder, replaceInPlace)\n      );\n      return { output: outputMin };\n    } else {\n      return { output: utils.setFileNameMin(input, output, replaceInPlace ? undefined : publicFolder, replaceInPlace) };\n    }\n  }\n};\n\n/**\n * Handle wildcards in a path, get the real path of each files.\n *\n * @param {String|Array} input - Path with wildcards\n * @param {String} publicFolder - Path to the public folder\n * @return {Object}\n */\nconst wildcards = (input: string | string[], publicFolder?: string) => {\n  // If it's a string\n  if (!Array.isArray(input)) {\n    return wildcardsString(input, publicFolder);\n  }\n\n  return wildcardsArray(input, publicFolder);\n};\n\n/**\n * Handle wildcards in a path (string only), get the real path of each files.\n *\n * @param {String} input - Path with wildcards\n * @param {String} publicFolder - Path to the public folder\n * @return {Object}\n */\nconst wildcardsString = (input: string, publicFolder?: string) => {\n  const output: { input?: string[] } = {};\n\n  if (input.indexOf('*') > -1) {\n    output.input = getFilesFromWildcards(input, publicFolder);\n  }\n\n  return output;\n};\n\n/**\n * Handle wildcards in a path (array only), get the real path of each files.\n *\n * @param {Array} input - Path with wildcards\n * @param {String} publicFolder - Path to the public folder\n * @return {Object}\n */\nconst wildcardsArray = (input: string[], publicFolder?: string) => {\n  const output: { input?: string[] } = {};\n  let isWildcardsPresent = false;\n\n  output.input = input;\n\n  // Transform all wildcards to path file\n  const inputWithPublicFolder = input.map(item => {\n    if (item.indexOf('*') > -1) {\n      isWildcardsPresent = true;\n    }\n    return (publicFolder || '') + item;\n  });\n\n  if (isWildcardsPresent) {\n    output.input = globSync(inputWithPublicFolder);\n  }\n\n  // Remove all wildcards from array\n  for (let i = 0; i < output.input.length; i++) {\n    if (output.input[i].indexOf('*') > -1) {\n      output.input.splice(i, 1);\n\n      i--;\n    }\n  }\n\n  return output;\n};\n\n/**\n * Get the real path of each files.\n *\n * @param {String} input - Path with wildcards\n * @param {String} publicFolder - Path to the public folder\n * @return {Object}\n */\nconst getFilesFromWildcards = (input: string, publicFolder?: string) => {\n  let output: string[] = [];\n\n  if (input.indexOf('*') > -1) {\n    output = globSync((publicFolder || '') + input);\n  }\n\n  return output;\n};\n\n/**\n * Prepend the public folder to each file.\n *\n * @param {String|Array} input - Path to file(s)\n * @param {String} publicFolder - Path to the public folder\n * @return {Object}\n */\nconst setPublicFolder = (input: string | string[], publicFolder: string) => {\n  const output: { input?: string | string[] } = {};\n\n  if (typeof publicFolder !== 'string') {\n    return output;\n  }\n\n  publicFolder = path.normalize(publicFolder);\n\n  if (Array.isArray(input)) {\n    output.input = input.map(item => {\n      // Check if publicFolder is already in path\n      if (path.normalize(item).indexOf(publicFolder) > -1) {\n        return item;\n      }\n      return path.normalize(publicFolder + item);\n    });\n    return output;\n  }\n\n  input = path.normalize(input);\n\n  // Check if publicFolder is already in path\n  if (input.indexOf(publicFolder) > -1) {\n    output.input = input;\n    return output;\n  }\n\n  output.input = path.normalize(publicFolder + input);\n\n  return output;\n};\n\n/**\n * Check if some settings are here.\n *\n * @param {Object} settings\n */\nconst checkMandatories = (settings: Settings) => {\n  ['compressor', 'input', 'output'].forEach((item: string) => mandatory(item, settings));\n};\n\n/**\n * Check if some settings are here for memory content.\n *\n * @param {Object} settings\n */\nconst checkMandatoriesMemoryContent = (settings: Settings) => {\n  ['compressor', 'content'].forEach((item: string) => mandatory(item, settings));\n};\n\n/**\n * Check if the setting exist.\n *\n * @param {String} setting\n * @param {Object} settings\n */\nconst mandatory = (setting: string, settings: { [key: string]: any }) => {\n  if (!settings[setting]) {\n    throw new Error(setting + ' is mandatory.');\n  }\n};\n\n/**\n * Expose `setup()`.\n */\nexport { setup };\n","/*!\n * node-minify\n * Copyright(c) 2011-2023 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport fs from 'fs';\nimport mkdirp from 'mkdirp';\nimport { utils } from '@node-minify/utils';\nimport { Settings } from '@node-minify/types';\n\n/**\n * Run compressor.\n *\n * @param {Object} settings\n */\nconst compress = (settings: Settings): Promise<string> | string => {\n  if (typeof settings.compressor !== 'function') {\n    throw new Error(`compressor should be a function, maybe you forgot to install the compressor`);\n  }\n\n  if (settings.output) {\n    createDirectory(settings.output);\n  }\n\n  if (Array.isArray(settings.output)) {\n    return settings.sync ? compressArrayOfFilesSync(settings) : compressArrayOfFilesAsync(settings);\n  } else {\n    return utils.compressSingleFile(settings);\n  }\n};\n\n/**\n * Compress an array of files in sync.\n *\n * @param {Object} settings\n */\nconst compressArrayOfFilesSync = (settings: Settings): any => {\n  return (\n    Array.isArray(settings.input) &&\n    settings.input.forEach((input, index) => {\n      const content = utils.getContentFromFiles(input);\n      return utils.runSync({ settings, content, index });\n    })\n  );\n};\n\n/**\n * Compress an array of files in async.\n *\n * @param {Object} settings\n */\nconst compressArrayOfFilesAsync = (settings: Settings): Promise<string | void> => {\n  let sequence: Promise<string | void> = Promise.resolve();\n  Array.isArray(settings.input) &&\n    settings.input.forEach((input, index) => {\n      const content = utils.getContentFromFiles(input);\n      sequence = sequence.then(() => utils.runAsync({ settings, content, index }));\n    });\n  return sequence;\n};\n\n/**\n * Create folder of the target file.\n *\n * @param {String} file - Full path of the file\n */\nconst createDirectory = (file: string) => {\n  if (Array.isArray(file)) {\n    file = file[0];\n  }\n  const dir = file && file.substr(0, file.lastIndexOf('/'));\n  if (!dir) {\n    return;\n  }\n  if (!fs.statSync(dir).isDirectory()) {\n    mkdirp.sync(dir);\n  }\n};\n\n/**\n * Expose `compress()`.\n */\nexport { compress };\n","/*!\n * node-minify\n * Copyright(c) 2011-2023 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport { utils } from '@node-minify/utils';\nimport { Settings } from '@node-minify/types';\n\n/**\n * Run compressor.\n *\n * @param {Object} settings\n */\nconst compressInMemory = (settings: Settings): Promise<string> | string => {\n  if (typeof settings.compressor !== 'function') {\n    throw new Error(`compressor should be a function, maybe you forgot to install the compressor`);\n  }\n\n  return utils.compressSingleFile(settings);\n};\n\n/**\n * Expose `compress()`.\n */\nexport { compressInMemory };\n","/*!\n * node-minify\n * Copyright(c) 2011-2023 Rodolphe Stoclin\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nimport { setup } from './setup';\nimport { compress } from './compress';\nimport { compressInMemory } from './compressInMemory';\nimport { Settings } from '@node-minify/types';\n\n/**\n * Run node-minify.\n *\n * @param {Object} settings - Settings from user input\n */\nconst minify = (settings: Settings) => {\n  return new Promise((resolve, reject) => {\n    const method: any = settings.content ? compressInMemory : compress;\n    settings = setup(settings);\n    if (!settings.sync) {\n      method(settings)\n        .then((minified: string) => {\n          if (settings.callback) {\n            settings.callback(null, minified);\n          }\n          resolve(minified);\n        })\n        .catch((err: Error) => {\n          if (settings.callback) {\n            settings.callback(err);\n          }\n          reject(err);\n        });\n    } else {\n      const minified: string = method(settings);\n      if (settings.callback) {\n        settings.callback(null, minified);\n      }\n      resolve(minified);\n    }\n  });\n};\n\n/**\n * Expose `minify()`.\n */\nminify.default = minify;\nexport = minify;\n"],"mappings":"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","names":["utils","utils"]}